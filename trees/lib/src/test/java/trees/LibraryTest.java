/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Supplier;

import static org.junit.jupiter.api.Assertions.*;
import static trees.Library.treeFizzBuzz;


class LibraryTest {
    @Test void someLibraryMethodReturnsTrue() {
        Library classUnderTest = new Library();
        assertTrue(classUnderTest.someLibraryMethod(), "someLibraryMethod should return 'true'");
    }
    // Can successfully instantiate an empty tree
    @Test void emptyTree() {
        BinaryTree<Integer> newTree = new BinaryTree<>();
        assertTrue(newTree instanceof BinaryTree);
        assertEquals("empty tree lists" , newTree.toString());
    }

    // Can successfully instantiate a tree with a single root node
    @Test void instantiateRoot() {
        BinaryTree<Integer> newTree = new BinaryTree<>();
        Node<Integer> singleTreeRoot = new Node<>(8);

        ArrayList<Integer> testList = new ArrayList<>();
        testList.add(8);

        assertEquals(testList , newTree.inOrder(singleTreeRoot));
        assertEquals(8, singleTreeRoot.value);
        assertEquals(null , singleTreeRoot.leftChild);
        assertEquals(null , singleTreeRoot.rightChild);
    }

    // Can successfully add a left child and right child to a single root node
    @Test void leftAndRightChild() {
        BinaryTree<Integer> newTree = new BinaryTree<>();
        Node<Integer> node1 = new Node<>(2);
        Node<Integer> node2 = new Node<>(9);
        Node<Integer> treeRoot = new Node<>(5 , node1 , node2);
        assertEquals( 5 , treeRoot.value);
        assertEquals( 2 , treeRoot.leftChild.value);
        assertEquals( 9 , treeRoot.rightChild.value);
    }

    // Can successfully return traversal
    @Test void traversalTest() {

        BinaryTree<Integer> newTree = new BinaryTree<>();

        Node<Integer> node1 = new Node<>(2);
        Node<Integer> node2 = new Node<>(3);
        Node<Integer> node3 = new Node<>(1, node1, node2);
        Node<Integer> node5 = new Node<>(6);
        Node<Integer> node4 = new Node<>(4, node5, null);
        Node<Integer> treeRoot = new Node<>(5, node3, node4);

        // Can successfully return a collection from a preorder traversal
        // Node order as perOrder  [5, 1, 2, 3, 4, 6]
        List<Integer> preTestList = new ArrayList<>();
        preTestList.add(5);
        preTestList.add(1);
        preTestList.add(2);
        preTestList.add(3);
        preTestList.add(4);
        preTestList.add(6);
        assertEquals( preTestList , newTree.preOrder(treeRoot));

        // Can successfully return a collection from a inOrder traversal
        // Node order as inOrder  [2, 1, 3, 5, 6, 4]
        List<Integer> inTestList = new ArrayList<>();
        inTestList.add(2);
        inTestList.add(1);
        inTestList.add(3);
        inTestList.add(5);
        inTestList.add(6);
        inTestList.add(4);
        assertEquals( inTestList , newTree.inOrder(treeRoot));

        // Can successfully return a collection from a postOrder traversal
        // Node order as postOrder  [2, 3, 1, 6, 4, 5]
        List<Integer> postTestList = new ArrayList<>();
        postTestList.add(2);
        postTestList.add(3);
        postTestList.add(1);
        postTestList.add(6);
        postTestList.add(4);
        postTestList.add(5);
        assertEquals( postTestList , newTree.postOrder(treeRoot));

        // Test all traversal
        String test = "BinaryTree{, preOrderList=[5, 1, 2, 3, 4, 6], inOrderList=[2, 1, 3, 5, 6, 4], postOrderList=[2, 3, 1, 6, 4, 5]}";
        assertEquals(test , newTree.toString());
    }
    @Test void maximumValueEmpty() {

        // Test maximumValue if list is empty
        BinaryTree<Integer> newTree = new BinaryTree<>();
        assertEquals( 0 , newTree.maximumValue());

        // Test maximumValue if list has only the root
        newTree.root = new Node<>(5);
        assertEquals( 5 , newTree.maximumValue());

        // Test maximumValue in the happy path
        Node<Integer> node1 = new Node<>(2);
        Node<Integer> node2 = new Node<>(-5);
        Node<Integer> node3 = new Node<>(1, node1, node2);
        Node<Integer> node5 = new Node<>(6);
        Node<Integer> node4 = new Node<>(4, node5, null);
        newTree.root.rightChild = node4;
        newTree.root.leftChild = node3;
        assertEquals( 6, newTree.maximumValue());


    }

    @Test void bredthFirstTest() {

//        // Test maximumValue if list is empty
        BinaryTree<Integer> newTree = new BinaryTree<>();
        assertNull(Library.breadthFirst(newTree));

        // Test maximumValue if list has only the root
        newTree.root = new Node<>(5);
        ArrayList<Integer> response=new ArrayList<>();
        response.add(5);

        assertEquals( response , Library.breadthFirst(newTree));

        // Test maximumValue in the happy path
        Node<Integer> node1 = new Node<>(2);
        Node<Integer> node2 = new Node<>(-5);
        Node<Integer> node3 = new Node<>(1, node1, node2);
        Node<Integer> node5 = new Node<>(6);
        Node<Integer> node4 = new Node<>(4, node5, null);
        newTree.root.rightChild = node4;
        newTree.root.leftChild = node3;
        ArrayList<Integer> response1=new ArrayList<>();
        response1.add(5);
        response1.add(1);
        response1.add(4);
        response1.add(2);
        response1.add(-5);
        response1.add(6);
        assertEquals( response1, Library.breadthFirst(newTree));

    }

    @Test void fuzzBuzzKTreeTest() {
        Node<Integer> root = new Node();
        ArrayList<String> testList = new ArrayList<>();

        // Test while K-tree empty
        assertEquals(testList , treeFizzBuzz(root));

        // Test while K-tree has only the root
        root.value = 0;
        testList.add("FizzBuzz");
        assertEquals(testList , treeFizzBuzz(root));

        // Test K-tree in the happy path
        root.child.add(new Node(2));
        root.child.add(new Node(3));
        root.child.add(new Node(5));
        root.child.get(0).child.add(new Node(12));
        root.child.get(0).child.add(new Node(22));
        root.child.get(0).child.add(new Node(15));
        root.child.get(1).child.add(new Node(20));
        root.child.get(2).child.add(new Node(17));

        testList.add("\""+2+"\"");
        testList.add("Fizz");
        testList.add("Buzz");
        testList.add("Fizz");
        testList.add("\""+22+"\"");
        testList.add("FizzBuzz");
        testList.add("Buzz");
        testList.add("\""+17+"\"");

        assertEquals( testList, treeFizzBuzz(root));
    }



}
